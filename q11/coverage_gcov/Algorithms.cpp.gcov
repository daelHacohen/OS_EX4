        -:    0:Source:Algorithms.cpp
        -:    0:Graph:./Algorithms.gcno
        -:    0:Data:./Algorithms.gcda
        -:    0:Runs:3
        -:    1:#include "Algorithms.hpp"
        -:    2:#include <vector>
        -:    3:#include <list>
        -:    4:#include <stack>
        -:    5:#include<queue>
        -:    6:#include <iostream>
        -:    7:#include <algorithm>
        -:    8:#include <climits>
        -:    9:#include "UnionFind.hpp"
        -:   10:
        -:   11:using namespace std;
        -:   12:using namespace graph;
        -:   13:/**
        -:   14: * Performs Breadth-First Search (BFS) traversal on the given graph,
        -:   15: * starting from the specified vertex.
        -:   16: *
        -:   17: * @param g The input graph (undirected).
        -:   18: * @param start The starting vertex for the BFS traversal.
        -:   19: * @return A new graph representing the BFS tree (spanning tree rooted at start).
        -:   20: * @throws Exception if the graph is empty or the start vertex is invalid.
        -:   21: */
        -:   22:
function _ZN5graph10Algorithms12Euler_circleERKNS_5GraphEi called 1 returned 100% blocks executed 66%
        1:   23:    bool Algorithms::Euler_circle(const Graph& d, int start) {
        1:   24:        Graph g=d;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   25:        // for (int i = 0; i < g.getNumVertices(); i++)
        -:   26:        // {
        -:   27:
        -:   28:            
        -:   29:        // }
        -:   30:        
        1:   31:        int n = g.getNumVertices();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       1*:   32:        if (n <= 0) throw "Graph is empty.";
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 never executed
       1*:   33:        if (start < 0 || start >= n) throw "this is not a valid start";
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
call    5 never executed
        1:   34:        Graph tree(n);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      10*:   35:        bool* visited = new bool[n]{false};
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
branch  6 taken 90%
branch  7 taken 10% (fallthrough)
branch  8 never executed (fallthrough)
branch  9 never executed
call   10 never executed
        -:   36:
        1:   37:        std::queue<int> q ;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:   38:        q.push(start);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:   39:        visited[start] = true;
        -:   40:
       11:   41:        while (!q.empty()) {
call    0 returned 100%
branch  1 taken 91%
branch  2 taken 9% (fallthrough)
       10:   42:            int current = q.front();
call    0 returned 100%
       10:   43:            q.pop();
call    0 returned 100%
       10:   44:            Neighbor** adj = g.getAdjList();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       10:   45:            Neighbor* neighbor = adj[current];
       30:   46:            while (neighbor) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       20:   47:                int v = neighbor->vertex;
       20:   48:                if (!visited[v]) {
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
        9:   49:                    visited[v] = true;
        9:   50:                    tree.addEdge(current, v, neighbor->weight);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        9:   51:                    q.push(v);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   52:                }
       20:   53:                neighbor = neighbor->next;
        -:   54:            }
        -:   55:        }
       11:   56:        for (int i = 0; i < n; i++)//check if there is more then one connection  compenent
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   57:        {
       10:   58:            Neighbor** adj = g.getAdjList();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
      10*:   59:            if (visited[i]==false && adj[i]!=nullptr)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed (fallthrough)
branch  3 never executed
        -:   60:            {
    #####:   61:                delete[] visited;
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####:   62:                return false;
        -:   63:            }
        -:   64:            
        -:   65:        }
        1:   66:        if(!g.isEven()){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        1:   67:            delete[] visited;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        1:   68:            return false;
        -:   69:        }// check if the number of neighbors for etch vertex is even
        -:   70:   
    #####:   71:        delete[] visited;
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####:   72:        return true;
        1:   73:    }
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 never executed
call    4 never executed
call    5 never executed
        -:   74:    //------------------MaxClique--------------------------------------------------
        -:   75:
function _ZN5graph10Algorithms8isCliqueERKNS_5GraphERKSt6vectorIiSaIiEE called 4 returned 100% blocks executed 95%
        4:   76:    bool Algorithms::isClique(const Graph& g, const vector<int>& nodes) {
        8:   77:    for (int i = 0; i < nodes.size(); i++) {
call    0 returned 100%
branch  1 taken 50%
branch  2 taken 50% (fallthrough)
        5:   78:        for (int j = i + 1; j < nodes.size(); j++) {
call    0 returned 100%
branch  1 taken 20%
branch  2 taken 80% (fallthrough)
        1:   79:            Neighbor** adj = g.getAdjList();
call    0 returned 100%
        1:   80:            bool isConnected = false;
        1:   81:            Neighbor* neighbor = adj[nodes[i]];
call    0 returned 100%
        4:   82:            while (neighbor) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        4:   83:                if (neighbor->vertex == nodes[j]) {
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
        1:   84:                    isConnected = true;
        1:   85:                    break;
        -:   86:                }
        3:   87:                neighbor = neighbor->next;
        -:   88:            }
       1*:   89:            if (!isConnected) return false;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   90:        }
        -:   91:    }
        4:   92:    return true;
        -:   93:}
        -:   94:
        -:   95:
function _ZN5graph10Algorithms13findMaxCliqueERKNS_5GraphEi called 1 returned 100% blocks executed 82%
        1:   96:    vector<int> Algorithms::findMaxClique(const Graph& g, int n) {
        1:   97:    vector<int> maxClique;
call    0 returned 100%
        -:   98:    
        5:   99:    for (int i = 0; i < (1 << n); i++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        4:  100:        vector<int> clique;
call    0 returned 100%
       12:  101:        for (int j = 0; j < n; j++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        8:  102:            if (i & (1 << j)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        4:  103:                clique.push_back(j);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  104:            }
        -:  105:        }
        4:  106:        if (isClique(g, clique) && clique.size() > maxClique.size()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 50% (fallthrough)
branch  8 taken 50%
branch  9 taken 50% (fallthrough)
branch 10 taken 50%
        2:  107:            maxClique = clique;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  108:        }
        4:  109:    }
call    0 returned 100%
call    1 never executed
        1:  110:    return maxClique;
    =====:  111:}
call    0 never executed
        -:  112:
        -:  113:
        -:  114:    //-----------------------number of cluqe-------------------
        -:  115:
function _ZN5graph10Algorithms12countCliquesERKNS_5GraphEi called 0 returned 0% blocks executed 0%
    #####:  116:    int Algorithms::countCliques(const Graph& g, int n) {
    #####:  117:    int cliqueCount = 0;
    #####:  118:    for (int i = 0; i < (1 << n); i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  119:        vector<int> clique;
call    0 never executed
    #####:  120:        for (int j = 0; j < n; j++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  121:            if (i & (1 << j)) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  122:                clique.push_back(j);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  123:            }
        -:  124:        }
    #####:  125:        if (isClique(g, clique)) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:  126:            cliqueCount++;
        -:  127:        }
    #####:  128:    }
call    0 never executed
call    1 never executed
    #####:  129:    return cliqueCount;
        -:  130:}
        -:  131:
        -:  132:
        -:  133://------------------MAX FLOW--------------------------
function _ZN5graph10Algorithms13fordFulkersonERSt6vectorIS1_IiSaIiEESaIS3_EEii called 1 returned 100% blocks executed 36%
        1:  134:int Algorithms::fordFulkerson(vector<vector<int>>& graph, int s, int t) {
        1:  135:    int n = graph.size();
call    0 returned 100%
        1:  136:    vector<vector<int>> rGraph = graph;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  137:    vector<int> parent(n);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  138:    int maxFlow = 0;
        -:  139:
        1:  140:    while (bfs(rGraph, s, t, parent)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
    #####:  141:        int pathFlow = INT_MAX;
    #####:  142:        for (int v = t; v != s; v = parent[v]) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  143:            int u = parent[v];
call    0 never executed
    #####:  144:            pathFlow = min(pathFlow, rGraph[u][v]);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  145:        }
        -:  146:
    #####:  147:        for (int v = t; v != s; v = parent[v]) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:  148:            int u = parent[v];
call    0 never executed
    #####:  149:            rGraph[u][v] -= pathFlow;
call    0 never executed
call    1 never executed
    #####:  150:            rGraph[v][u] += pathFlow;
call    0 never executed
call    1 never executed
call    2 never executed
        -:  151:        }
    #####:  152:        maxFlow += pathFlow;
        -:  153:    }
        1:  154:    return maxFlow;
        1:  155:}
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
        -:  156://-----------------kruskal-----------------------
        -:  157:
        -:  158:
        -:  159:
        -:  160:
        -:  161:
function _ZN5graph10Algorithms10findParentEiRSt6vectorIiSaIiEE called 53 returned 100% blocks executed 100%
       53:  162:int Algorithms::findParent(int node, vector<int>& parent) {
       53:  163:    if (parent[node] == node) return node;
call    0 returned 100%
branch  1 taken 72% (fallthrough)
branch  2 taken 28%
       15:  164:    return parent[node] = findParent(parent[node], parent);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  165:}
        -:  166:
function _ZN5graph10Algorithms9unionSetsEiiRSt6vectorIiSaIiEES4_ called 9 returned 100% blocks executed 88%
        9:  167:void Algorithms::unionSets(int u, int v, vector<int>& parent, vector<int>& rank) {
        9:  168:    int root_u = findParent(u, parent);
call    0 returned 100%
        9:  169:    int root_v = findParent(v, parent);
call    0 returned 100%
        9:  170:    if (root_u != root_v) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        9:  171:        if (rank[root_u] > rank[root_v]) parent[root_v] = root_u;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
call    4 returned 100%
       3*:  172:        else if (rank[root_u] < rank[root_v]) parent[root_u] = root_v;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  173:        else {
        3:  174:            parent[root_v] = root_u;
call    0 returned 100%
        3:  175:            rank[root_u]++;
call    0 returned 100%
        -:  176:        }
        -:  177:    }
        9:  178:}
        -:  179:
function _ZN5graph10Algorithms10kruskalMSTEiRSt6vectorINS0_4EdgeESaIS2_EE called 1 returned 100% blocks executed 72%
        1:  180:int Algorithms::kruskalMST(int n, vector<Edge>& edges) {
        1:  181:    sort(edges.begin(), edges.end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
        2:  182:    vector<int> parent(n);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  183:    vector<int> rank(n, 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
       11:  184:    for (int i = 0; i < n; i++) parent[i] = i;
call    0 returned 100%
branch  1 taken 91%
branch  2 taken 9% (fallthrough)
        -:  185:
        1:  186:    int mstWeight = 0;
       11:  187:    for (const Edge& edge : edges) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 91%
branch  6 taken 9% (fallthrough)
       10:  188:        int u = edge.u;
       10:  189:        int v = edge.v;
       10:  190:        if (findParent(u, parent) != findParent(v, parent)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 90% (fallthrough)
branch  7 taken 10%
        9:  191:            unionSets(u, v, parent, rank);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        9:  192:            mstWeight += edge.weight;
        -:  193:        }
        -:  194:    }
        1:  195:    return mstWeight;
        1:  196:}
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
        -:  197:    //---------------------bfs-------------------------
        -:  198:
        -:  199:
function _ZN5graph10Algorithms3bfsERSt6vectorIS1_IiSaIiEESaIS3_EEiiRS3_ called 1 returned 100% blocks executed 63%
        1:  200:bool Algorithms::bfs(vector<vector<int>>& rGraph, int s, int t, vector<int>& parent) {
        1:  201:    int n = rGraph.size();
call    0 returned 100%
        1:  202:    vector<bool> visited(n, false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        1:  203:    queue<int> q;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  204:    q.push(s);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  205:    visited[s] = true;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        -:  206:
        2:  207:    while (!q.empty()) {
call    0 returned 100%
branch  1 taken 50%
branch  2 taken 50% (fallthrough)
        1:  208:        int u = q.front();
call    0 returned 100%
        1:  209:        q.pop();
call    0 returned 100%
       11:  210:        for (int v = 0; v < n; v++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
      10*:  211:            if (!visited[v] && rGraph[u][v] > 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 90% (fallthrough)
branch  5 taken 10%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
    #####:  212:                q.push(v);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  213:                visited[v] = true;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
    #####:  214:                parent[v] = u;
call    0 never executed
        -:  215:            }
        -:  216:        }
        -:  217:    }
        2:  218:    return visited[t];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        1:  219:}
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
        -:  220:
        -:  221:
        -:  222:   
        -:  223:
