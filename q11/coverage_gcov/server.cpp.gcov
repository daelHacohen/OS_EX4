        -:    0:Source:server.cpp
        -:    0:Graph:./server.gcno
        -:    0:Data:./server.gcda
        -:    0:Runs:1
        -:    1:#include <iostream>
        -:    2:#include <unistd.h>
        -:    3:#include <netinet/in.h>
        -:    4:#include <cstring>
        -:    5:#include <fcntl.h>
        -:    6:#include <list>
        -:    7:#include <thread>
        -:    8:#include <string>
        -:    9:#include <algorithm>
        -:   10:#include <cmath>
        -:   11:#include <chrono>
        -:   12:#include <mutex>
        -:   13:#include "Graph.hpp"
        -:   14:#include "Algorithms.hpp"
        -:   15:#include <iostream>
        -:   16:#include <cstring>
        -:   17:#include <sys/socket.h>
        -:   18:#include <arpa/inet.h>
        -:   19:#include <unistd.h>
        -:   20:
        -:   21:#include <bits/stdc++.h>
        -:   22:#include "TSQueue.hpp"
        -:   23:#include "objectActive.hpp"
        -:   24:
        -:   25:#include "stradegy.hpp"
        -:   26:#include "factory.hpp"
        -:   27:#include <atomic>  
        -:   28:
        -:   29:
        -:   30:using namespace graph;
        -:   31:using namespace std::chrono;
        -:   32:using namespace std;
        -:   33:
        -:   34:
        -:   35:#define PORT 8080
        -:   36:
        -:   37:
        -:   38:
        -:   39:
        -:   40:static std::atomic<int> accepted_count{0};
        -:   41:static std::atomic<bool> shutting_down{false};
        -:   42:
        -:   43:// יצירת השלבים
        -:   44:static EulerStage      ST_euler;
        -:   45:static MaxFlowStage    ST_maxflow;
        -:   46:static MaxCliqueStage  ST_maxclique;
        -:   47:static MstStage        ST_mst;
        -:   48:
        -:   49:
        -:   50:
function _ZL14start_pipelinev called 1 returned 100% blocks executed 100%
        1:   51:static void start_pipeline(){
        1:   52:    ST_euler.set_next(&ST_maxflow);
call    0 returned 100%
        1:   53:    ST_maxflow.set_next(&ST_maxclique);
call    0 returned 100%
        1:   54:    ST_maxclique.set_next(&ST_mst);
call    0 returned 100%
        -:   55:
        1:   56:    ST_mst.start();
call    0 returned 100%
        1:   57:    ST_maxclique.start();
call    0 returned 100%
        1:   58:    ST_maxflow.start();
call    0 returned 100%
        1:   59:    ST_euler.start();
call    0 returned 100%
        1:   60:}
function _ZL13stop_pipelinev called 1 returned 100% blocks executed 100%
        1:   61:static void stop_pipeline(){ 
        -:   62:
        1:   63:    ST_euler.stop();
call    0 returned 100%
        1:   64:    ST_maxflow.stop();
call    0 returned 100%
        1:   65:    ST_maxclique.stop();
call    0 returned 100%
        1:   66:    ST_mst.stop();
call    0 returned 100%
        1:   67:}
        -:   68:
        -:   69:
        -:   70:// string calculate(string name, Graph& g,int start,int end){
        -:   71://     factory f;
        -:   72://     stradegy* action=f.create(name);
        -:   73://     return action->run(g,start,end);
        -:   74:    
        -:   75:    
        -:   76:// }
        -:   77:
        -:   78:
        -:   79:static int server_sock = -1;
        -:   80:static std::mutex m;
        -:   81:static std::condition_variable cv;
        -:   82:static bool leader_present = false;
        -:   83:static bool stop = false;
        -:   84:
function _ZL11worker_loopi called 16 returned 100% blocks executed 73%
       16:   85:static void worker_loop(int tid) {
       17:   86:    while(!stop) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:   87:        // --- להפוך למנהיג: להמתין עד שאין מנהיג פעיל ---
        -:   88:        {
       17:   89:            std::unique_lock<std::mutex> lock(m);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
function _ZZL11worker_loopiENKUlvE_clEv called 32 returned 100% blocks executed 100%
       49:   90:            cv.wait(lock, [] { return shutting_down.load() || !leader_present; });
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 53% (fallthrough)
branch  5 taken 47%
branch  6 taken 12% (fallthrough)
branch  7 taken 88%
       17:   91:            if (shutting_down.load()) 
call    0 returned 100%
branch  1 taken 88% (fallthrough)
branch  2 taken 12%
        -:   92:            {
       15:   93:            return; // יציאה נקייה מה-thread אם כבר מכבים
        -:   94:            }
        2:   95:            leader_present = true; // אני המנהיג כרגע
       17:   96:        }
call    0 returned 100%
branch  1 taken 12% (fallthrough)
branch  2 taken 88%
call    3 never executed
        -:   97:
        -:   98:        // --- המנהיג ממתין לקליינט חדש ---
        2:   99:        sockaddr_in cli{}; socklen_t clilen = sizeof(cli);
        2:  100:        int client_fd = ::accept(server_sock, (sockaddr*)&cli, &clilen);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  101:        if (client_fd < 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  102:            // שחרור הנהגה כדי שלא ניתקע
        -:  103:            {
        1:  104:                std::lock_guard<std::mutex> lk(m);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  105:                leader_present = false;
        1:  106:                cv.notify_one(); // קדם מנהיג חדש
call    0 returned 100%
        1:  107:            }
call    0 returned 100%
        1:  108:            if (shutting_down.load()) return;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####:  109:            if (errno == EINTR) continue;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  110:            perror("accept");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  111:            continue;
    #####:  112:        }
        1:  113:        int now = ++accepted_count;
call    0 returned 100%
       1*:  114:        bool i_am_the_one_to_shutdown = (now >= 1) && !shutting_down.exchange(true); // <-- 1 במקום 2
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        1:  115:        if (i_am_the_one_to_shutdown) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  116:        ::shutdown(server_sock, SHUT_RDWR);
call    0 returned 100%
        1:  117:        ::close(server_sock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  118:
        -:  119:        // --- לקדם מנהיג חדש ולרדת להיות Worker ---
        -:  120:        
        1:  121:            std::lock_guard<std::mutex> lk(m);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  122:            leader_present = false; // מפנה תפקיד
        1:  123:            cv.notify_all();        // מעיר Follower – יהיה המנהיג הבא
call    0 returned 100%
        1:  124:        }
call    0 returned 100%
        -:  125:
        -:  126:        // ====== טיפול בלקוח ======
        -:  127:
        1:  128:    cout<<"the current client_fd is: "<< client_fd <<endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -:  129:    char buffer[1024];
        -:  130:    int recv_len;
        1:  131:    if ((recv_len = recv(client_fd, buffer, sizeof(buffer), 0)) == -1) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  132:        cerr << "Failed to receive message from client!" << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  133:        return;
        -:  134:    }
        -:  135:
        1:  136:    buffer[recv_len] = '\0';  // terminate string with NULL
        1:  137:    cout << "Message received from client: " << buffer << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -:  138:
        1:  139:    std::string input(buffer, recv_len);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  140:    int v, e, r;
        1:  141:    sscanf(input.c_str(), "%d,%d,%d", &v, &e, &r);
call    0 returned 100%
        -:  142:
        1:  143:    std::cout << "v=" << v << ", e=" << e << ", r=" << r << std::endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
call   18 returned 100%
branch 19 taken 100% (fallthrough)
branch 20 taken 0% (throw)
        -:  144:
        1:  145:    graph::Graph g(v);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  146:    g = g.generateRandomGraph(v,e);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        1:  147:    g.print_graph();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  148:
        1:  149:    auto g_rw = std::make_shared<graph::Graph>(std::move(g));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  150:    
        -:  151:
        1:  152:    auto req = std::make_shared<Request>();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  153:    req->client_fd = client_fd;
call    0 returned 100%
        1:  154:    req->job_id = std::chrono::steady_clock::now().time_since_epoch().count();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        1:  155:    req->V = v;
call    0 returned 100%
        1:  156:    req->R = r;
call    0 returned 100%
        1:  157:    req->g = g_rw;
call    0 returned 100%
call    1 returned 100%
        1:  158:    req->answer = "RESULTS:\n";
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  159:
        -:  160:    // דוחפים לפייפליין
        1:  161:    ST_euler.post(std::move(req));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
call    5 returned 100%
call    6 never executed
        1:  162:    ::close(server_sock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  163:    
        -:  164:    // ::close(client_fd);   // סוגר את החיבור ללקוח
        -:  165:
        -:  166:    // if (shutting_down.load()) {
        -:  167:    // return; // מסיים את ה-thread אם כבר התחלנו לכבות
        -:  168:    // }
        -:  169:    // stop_pipeline();
        -:  170:    //::close(server_sock);
        -:  171:    
        -:  172:    
        -:  173:
        -:  174:
        -:  175:   
        1:  176: }
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  177:}
        -:  178:
function main called 1 returned 100% blocks executed 67%
        1:  179:int main() {
        -:  180:    int client_sock;
        -:  181:    struct sockaddr_in server, client;
        1:  182:    socklen_t client_len = sizeof(client);
        -:  183:
        -:  184:    // create server socket
        1:  185:    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  186:        cerr << "Failed to create server socket!" << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  187:        return -1;
        -:  188:    }
        1:  189:    int optval = 1;
        1:  190:    if (setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  191:        cerr << "Failed to set SO_REUSEADDR option!" << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  192:        close(server_sock);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  193:        return -1;
        -:  194:    }
        -:  195:
        1:  196:    server.sin_family = AF_INET;
        1:  197:    server.sin_port = htons(PORT);  // port to listen on
        1:  198:    server.sin_addr.s_addr = INADDR_ANY;  // listen on any IP
        -:  199:
        -:  200:    // bind socket to address and port
        1:  201:    if (bind(server_sock, (struct sockaddr*)&server, sizeof(server)) == -1) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  202:        cerr << "Failed to bind socket to address and port!" << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  203:        return -1;
        -:  204:    }
        -:  205:
        -:  206:    // listen for connections
        1:  207:    if (listen(server_sock, 5) == -1) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  208:        cerr << "Failed to listen for connections!" << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  209:        return -1;
        -:  210:    }
        -:  211:
        1:  212:    cout << "Server listening on port " << PORT << "..." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
        -:  213:
        -:  214://----------------------------LF----------------------
        1:  215:    start_pipeline();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  216:
        -:  217:     // הפעלת Thread-Pool
        1:  218:    const unsigned hw = std::thread::hardware_concurrency();
call    0 returned 100%
       1*:  219:    const int N = hw ? int(hw) : 4;         // לפחות 4 ת’רדים לנוחות
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  220:    std::vector<std::thread> pool;
call    0 returned 100%
        1:  221:    pool.reserve(N);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       17:  222:    for (int i = 0; i < N; ++i) pool.emplace_back(worker_loop, i);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 94%
branch  4 taken 6% (fallthrough)
        -:  223:
        -:  224:    // מנהיג ראשון
        -:  225:    {
        1:  226:        std::lock_guard<std::mutex> lk(m);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  227:        leader_present = false;
        1:  228:        cv.notify_one();
call    0 returned 100%
        1:  229:    }
call    0 returned 100%
        -:  230:
       17:  231:    for (auto& t : pool) t.join();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 returned 100%
branch  8 taken 94%
branch  9 taken 6% (fallthrough)
        1:  232:    stop_pipeline();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  233:    ::close(server_sock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  234:    
        -:  235:
        -:  236:        
        -:  237:
        1:  238:    return 0;
        1:  239:}
call    0 returned 100%
call    1 never executed
